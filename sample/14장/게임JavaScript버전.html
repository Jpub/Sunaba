<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"><title>게임javascript버전</title>
<style>
<!--
td { width: 10px; height: 10px; }
body { background-color: black; }
.white { background-color: white; }
.black { background-color: black; }
.red { background-color: red; }
-->
</style>
<script>

메모리 = new Array()
화면 = new Array() //칸위치계산을위한 12×20 배열. 여기에 색을 넣고 있음
세로 = 1
가로 = 5
회전 = 0
종류 = 0
낙하카운트 = 0
왼쪽 = 0
오른쪽 = 0
위 = 0
if (window.addEventLisnter){ //표준
   window.addEventListener("load", 준비, true) //시작 위치 설정
   window.addEventListener("keydown", 키취득, true) // 키가 눌릴 때 해야 할 것 설정
}else{ //IE8 등의 옛날 브라우져용
   window.onload = 준비
   document.onkeydown = 키취득
}
function 준비(){
   //메모리를 999번까지 0으로 설정. javascript에선 '메모리'를 만들 필요가 없지만, Sunaba와 비슷하게 만들기 위한 것임.
   var 횟수 = 0
   while (횟수 < 1000){
      메모리[횟수] = 0
      횟수 = 횟수 + 1
   }
   
   횟수 = 0
   while (횟수 < (12 * 20)){
      화면[횟수] = 0
      횟수 = 횟수 + 1
   }
   
   var screen = document.getElementById("화면")
   var y = 0
   while (y < 20){
      var line = document.createElement("tr")
      var x = 0
      while (x < 12){
         var cell = document.createElement("td")
         cell.setAttribute("class", "black")
         line.appendChild(cell)
         x = x + 1
      }
      screen.appendChild(line)
      y = y + 1
   }
   //여기가 Sunaba 프로그램의 시작 부분에 해당
   패턴미리만들어두기()
   벽과바닥그리기() 
   window.setInterval(무한반복범위, 17) //「무한반복」이 1/60초(17ms) 단위로 참조되게 설정
}
function 키취득(ev){
   if (ev == null){ //IE8用
      ev = window.event
   }
   
   if (ev.keyCode == 37){
      왼쪽 = 1
   }
   if (ev.keyCode == 38){
      위 = 1
   }
   if (ev.keyCode == 39){
      오른쪽 = 1
   }
}
function 화면갱신하기(){ //배경색 변경
   var screen = document.getElementById("화면")
   var y = 0
   var line = screen.firstChild
   while (y < 20){
      var x = 0
      var cell = line.firstChild
      while (x < 12){
         var color = 화면[(y * 12) + x]
         var s = ""
         if (color == 0){
            s = "black"
         }else if (color == 999999){
            s = "white"
         }else if (color == 990000){
            s = "red"
         }
         cell.setAttribute("class", s)
         x = x + 1
         cell = cell.nextSibling
      }
      y = y + 1
      line = line.nextSibling
   }
}
//여기까지는 javascript 특유의 기능이 많지만, 
//아래는 Sunaba 버전의 게임과 대부분 같다.
function 무한반복범위(){
   //이동량.Sunaba와 달리 눌린 순간에 오른쪽, 왼쪽, 위를 1로 설정해 주는 구조가 있다.
   var 가로이동량 = 오른쪽 - 왼쪽
   var 세로이동량 = 0
   var 회전량 = 위
   
   왼쪽 = 0
   오른쪽 = 0
   위 = 0

   낙하카운트 = 낙하카운트 + 1
   if (낙하카운트 == 10){
      세로이동량 = 1
      낙하카운트  = 0
   }
   
   세로 = 세로 + 세로이동량
   가로 = 가로 + 가로이동량
   회전 = 회전 + 회전량
   if (겹친다(세로, 가로, 회전, 종류)){
      //戻す
      세로 = 세로 - 세로이동량
      가로 = 가로 - 가로이동량
      회전 = 회전 - 회전량
      if ((세로이동량 > 0) && (가로이동량 == 0)){
         쌓아서열지우기(세로, 가로, 회전, 종류)
         세로 = 1
         가로 = 5
         회전 = 0
         종류 = 종류 + 1
         if (종류 > 6){
            종류 = 0
         }
      }
   }
   사각형움직이기(세로, 가로, 회전, 종류)
}
function 패턴미리만들어두기(){
   메모리에6개기억시키기(500, 0, -1, 0, 1, 0, 2) //모양0
   메모리에6개기억시키기(506, -1, -1, 0, -1, 0, 1) //모양1
   메모리에6개기억시키기(512, 0, -1, -1, 0, 0, 1) //모양2
   메모리에6개기억시키기(518, 0, -1, -1, 1, 0, 1) //모양3
   메모리에6개기억시키기(524, 0, -1, 1, 0, 1, 1) //모양4
   메모리에6개기억시키기(530, 0, 1, 1, 0, 1, 1) //모양5
   메모리에6개기억시키기(536, 0, 1, 1, -1, 1, 0) //모양6
}
function 메모리에6개기억시키기(시작번호, 수0, 수1, 수2, 수3, 수4, 수5){
   메모리[시작번호 + 0] = 수0
   메모리[시작번호 + 1] = 수1
   메모리[시작번호 + 2] = 수2
   메모리[시작번호 + 3] = 수3
   메모리[시작번호 + 4] = 수4
   메모리[시작번호 + 5] = 수5
}
function 칸위치계산하기(세로, 가로, 회전, 종류){
   메모리[0] = 세로
   메모리[1] = 가로
   var 시작번호 = 500 + (종류 * 6)
   var 횟수 = 0
   while (횟수 < 3){
      var 상대세로 = 메모리[시작번호 + (횟수 * 2) + 0]
      var 상대가로 = 메모리[시작번호 + (횟수 * 2) + 1]
      var 회전횟수 = 0
      while (회전횟수 < 회전){
         //교체
         var 교체용 = 상대세로
         상대세로 = 상대가로
	 상대가로 = 교체용
	 //플러스/마이너스 교체
	 상대가로 = -상대가로
	 회전횟수 = 회전횟수 + 1
      }
      메모리[2 + (횟수 * 2)] = 세로 + 상대세로
      메모리[3 + (횟수 * 2)] = 가로 + 상대가로
      횟수 = 횟수 + 1
   }
}
function 겹친다(세로, 가로, 회전, 종류){
   칸위치계산하기(세로, 가로, 회전, 종류)
   return (메모리[100 + (메모리[0] * 12) + 메모리[1]] == 1) ||
      (메모리[100 + (메모리[2] * 12) + 메모리[3]] == 1) ||
      (메모리[100 + (메모리[4] * 12) + 메모리[5]] == 1) ||
      (메모리[100 + (메모리[6] * 12) + 메모리[7]] == 1)
}
function 쌓아서열지우기(세로, 가로, 회전, 종류){
   칸위치계산하기(세로, 가로, 회전, 종류)
   쌓기(메모리[0], 메모리[1])
   쌓기(메모리[2], 메모리[3])
   쌓기(메모리[4], 메모리[5])
   쌓기(메모리[6], 메모리[7])
   열지우기()
}
function 사각형움직이기(세로, 가로, 회전, 종류){
   칸위치계산하기(세로, 가로, 회전, 종류)
   사각형(메모리[0], 메모리[1], 990000) //빨강
   사각형(메모리[2], 메모리[3], 990000) //빨강
   사각형(메모리[4], 메모리[5], 990000) //빨강
   사각형(메모리[6], 메모리[7], 990000) //빨강
   화면갱신하기()
   사각형(메모리[0], 메모리[1], 0) //지우기
   사각형(메모리[2], 메모리[3], 0) //지우기
   사각형(메모리[4], 메모리[5], 0) //지우기
   사각형(메모리[6], 메모리[7], 0) //지우기
}
function 쌓기(세로, 가로){
   메모리[100 + (세로 * 12) + 가로] = 1
   사각형(세로, 가로, 999999)
}
function 벽과바닥그리기(){
   바닥그리기()
   벽그리기()
}
function 바닥그리기(){
   var 횟수 = 0
   while (횟수 < 20){
      쌓기(횟수, 0) //왼쪽
      쌓기(횟수, 11) //오른쪽
      횟수 = 횟수 + 1
   }
}
function 벽그리기(){
   var 횟수 = 0
   while (횟수 < 10){
      쌓기(19, 1 + 횟수)
      횟수 = 횟수 + 1
   }
}
function 사각형(세로, 가로, 色){
   //실제 그림 그리는 처리는 다른 곳에 있다
   화면[(세로 * 12) + 가로] = 色
}
function 열지우기(){
   var 세로 = 0
   while (세로 < 19){
      var 지워지나 = true
      var 가로 = 1
      while (가로 <= 10){
         지워지나 = 지워지나 && (메모리[100 + (세로 * 12) + 가로] == 1)
         가로 = 가로 + 1
      }
      if (지워지나){
         //쌓았다고 기억한 메모리를 0으로 설정
         var 가로 = 1
         while (가로 < 10){
            메모리[100 + (세로 * 12) + 가로] = 0 //메모리を0に
            사각형(세로, 가로, 0) //검정색으로 칠해서 지우기
            가로 = 가로 + 1
         }
         옮기기(세로)
      }
      세로 = 세로 + 1
   }
}
function 옮기기(지워지는열의세로){
   var 세로 = 지워지는열의세로 - 1
   while (세로 >= 0){
      var 가로 = 1
      while (가로 <= 10){
         if (메모리[100 + (세로 * 12) + 가로] == 1){
            메모리[100 + (세로 * 12) + 가로] = 0 //지우기
            사각형(세로, 가로, 0) 
            쌓기(세로 + 1, 가로)
         }
         가로 = 가로 + 1
      }
      세로 = 세로 - 1
   }
}
</script>
</head>
<body>
	<table id="화면"></table>
</body>
</html>
